/*
    test_rsa.c

    Test of entropy routines

    (CC) Creative Commons 2025 by Guillermo Amodeo Ojeda.

    I dedicate the software in this file to the public domain, so it is entirely free.
    Thus you may use it and/or redistribute it for whatever purpose you may choose.

    It is actually distributed with the hope that it would be useful to someone,
    but with no guarantee whatsoever. Not even the guarantee that it will work.

    Also, being free software, it is provided without warranty of any kind,
    not even the implied warranty of merchantability or fitness for a particular
    purpose. I also disclaim any liability arising from any use of this software.

    Read the CC license at https://creativecommons.org/publicdomain/zero/1.0/

    NOTES:

        - Written by Guillermo Amodeo Ojeda.                  
            
                        --oO0Oo--
*/

#include "rsa.h"

/* -------------------------------------- */

void print_bytes(char *prefix, void *d, size_t n)
{
    size_t t;
    unsigned char *dat;

    dat = (unsigned char *)d;

    if (prefix)
        printf("%s=", prefix);

    if (d)
    {
        for (t = 0; t < n; t++)
            printf("%02x", dat[t]);
        printf("\n");
    }
    else
    {
        printf("NULL\n");
    }
}

/* --------------- */

static void print_rsa_key(rsa_t *key)
{
    char tmp[(RSA_MAX_BYTES + 1) * 2];

    if (!key)
    {
        printf("--- RSA KEY NULL ---\n");
        return;
    }

    printf("--- RSA KEY %d bits (%d) ---\n", key->bits, key->bytes);    
    mp_copy_string(&(key->modulus), tmp, sizeof(tmp));
    printf("MOD =%s\n", tmp);
    mp_copy_string(&(key->exponent), tmp, sizeof(tmp));
    printf("EXP =%s\n", tmp);

    if(key->private_exponent)
    {
        mp_copy_string(key->private_exponent, tmp, sizeof(tmp));
        printf("PRIV=%s\n", tmp);
    }
    else
    {
        printf("PRIV=NULL\n");
    }
    
    if(key->p)
    {
        mp_copy_string(key->p, tmp, sizeof(tmp));
        printf("P=%s\n", tmp);
    }
    else
    {
        printf("P=NULL\n");
    }
    if(key->q)
    {
        mp_copy_string(key->q, tmp, sizeof(tmp));
        printf("Q=%s\n", tmp);
    }
    else
    {
        printf("Q=NULL\n");
    }


    printf("-----------------------------\n");
}

/* RSA Test from the test vectors of PKCS-1 v1.5 */

/* Example 1.4 (1024 bits) */

rsa_t *create_key1_test(void)
{
    char *mod = "a8b3b284af8eb50b387034a860f146c4919f318763cd6c5598c8ae4811a1e0ab"
                "c4c7e0b082d693a5e7fced675cf4668512772c0cbc64a742c6c630f533c8cc72"
                "f62ae833c40bf25842e984bb78bdbf97c0107d55bdb662f5c4e0fab9845cb514"
                "8ef7392dd3aaff93ae1e6b667bb3d4247616d4f5ba10d4cfd226de88d39f16fb";

    char *exp = "010001";

    char *priv = "53339cfdb79fc8466a655c7316aca85c55fd8f6dd898fdaf119517ef4f52e8fd"
                 "8e258df93fee180fa0e4ab29693cd83b152a553d4ac4d1812b8b9fa5af0e7f55"
                 "fe7304df41570926f3311f15c4d65a732c483116ee3d3d2d0af3549ad9bf7cbf"
                 "b78ad884f84d5beb04724dc7369b31def37d0cf539e9cfcdd3de653729ead5d1";
    return rsa_from_chars(mod, exp, priv);
}

unsigned char msg_1[26] =
    {
        0x52, 0xe6, 0x50, 0xd9, 0x8e, 0x7f, 0x2a, 0x04, 0x8b, 0x4f, 0x86, 0x85, 0x21, 0x53, 0xb9, 0x7e,
        0x01, 0xdd, 0x31, 0x6f, 0x34, 0x6a, 0x19, 0xf6, 0x7a, 0x85};

unsigned char rnd_1[99] =
    {
        0x26, 0x29, 0xa7, 0xaa, 0xc0, 0xc3, 0x90, 0x5e, 0x83, 0x1e, 0xb6, 0x02, 0x38, 0x8c, 0x54, 0x5a,
        0xf5, 0x54, 0xb9, 0x6b, 0x2a, 0xe5, 0x15, 0x32, 0xe9, 0xcc, 0xdb, 0x89, 0x72, 0xef, 0x30, 0xb6,
        0x4a, 0x2f, 0x98, 0xc6, 0x95, 0x29, 0x7a, 0x01, 0xc5, 0x81, 0x2a, 0x2c, 0x40, 0x15, 0x82, 0xf3,
        0x7b, 0x14, 0x4a, 0x3e, 0x90, 0xe5, 0x9d, 0x81, 0xb6, 0x90, 0x39, 0xc6, 0x4b, 0x84, 0x4b, 0x02,
        0x8c, 0x10, 0x5c, 0x8e, 0x68, 0x36, 0x15, 0xaf, 0xb6, 0x58, 0xb6, 0xc4, 0xd9, 0xf3, 0x82, 0x38,
        0xa7, 0x63, 0x01, 0xbb, 0x14, 0x44, 0x91, 0x13, 0xb6, 0x9d, 0xe1, 0x26, 0x04, 0x5e, 0x26, 0xf1,
        0x3e, 0xe6, 0xd7};

unsigned char enc_1[128] =
    {
        0x54, 0xdd, 0xb7, 0x84, 0x26, 0x8e, 0xad, 0xb3, 0x95, 0x5b, 0xd9, 0xf9, 0x49, 0x88, 0x42, 0x59,
        0x5a, 0xd2, 0x9f, 0xf8, 0xa6, 0x67, 0xfe, 0xb4, 0x1f, 0x6f, 0x53, 0x0c, 0xb6, 0x0b, 0xc9, 0x26,
        0xac, 0x6c, 0x71, 0xc7, 0x72, 0xf8, 0x03, 0xd0, 0x22, 0xb4, 0x1c, 0xa5, 0x72, 0x04, 0x22, 0x3b,
        0x27, 0xca, 0x79, 0xec, 0x5b, 0x72, 0x65, 0x2c, 0xa9, 0xaf, 0xbf, 0x40, 0xdc, 0x2f, 0x6a, 0x0e,
        0x13, 0xbc, 0xd6, 0x0d, 0x37, 0xf7, 0x95, 0x04, 0xb0, 0xff, 0xcc, 0x01, 0xcf, 0x53, 0x42, 0xd6,
        0xd3, 0x4a, 0xc6, 0xf1, 0xf2, 0xf9, 0xf2, 0xf4, 0x87, 0x46, 0x25, 0xb9, 0xfd, 0xbb, 0x7d, 0xda,
        0x2e, 0xc8, 0x7d, 0xf0, 0xcf, 0x87, 0x25, 0x97, 0x98, 0xdf, 0x86, 0xa0, 0x6b, 0xd5, 0xae, 0xf7,
        0x35, 0x4b, 0x8c, 0xb1, 0xcb, 0x13, 0x75, 0x75, 0xf4, 0xcf, 0xbc, 0x46, 0x28, 0x1b, 0xb3, 0x31};

/* Example 14.2 (2048 bits) */

rsa_t *create_key14_test(void)
{
    char *mod="be0ca01f9c172166f912391e5d58ddc30d5dd0279a49bb312a31e4c8a66a52fb"
             "4e8b6742faacb224c3039f1e198f3323b888ba0e35bb94c511bd22b886405a71"
             "5e409de3bceb4fc9911b0e9c3b1e42e257d5bbea0722b5d5dd3537569dc75606"
             "46a750b87eaa6f3a405a94bf2ada72b50a4b0187bb9d00ec451d50a6a91a1e2a"
             "91192a7fd756b900141fe88f96e2080dfdd80166a7bf67e37144d09e3af89974"
             "e57c72b03a2b88fd2995252ace4f30e2e47c2818057240536b58db4207509e59";

    char *exp="010001";

    char *priv="f37d28d61f2899a5c0e0a0749d1389387c64c8c358a971dad13cff85c59a62dd"
               "a7bbc0f7e5bdc65dff9de9c745404631758148168dfe6ac0a2876a56053bab2a"
               "2a9ff272794dd5d8139eed10bcfb4df33020d59e3048fd2f0c431426145e36a1"
               "d0a6bfce4443ef3c7e31d4a92fb8517a49f788c3b4e137395a4beeea63e0e0ad"
               "c3224f980925037df6f5b26c007239b4f01f8a9a61ea0b5119bc9d5496a95b60"
               "ea766ccbade037e340324f25f02e7245c236eae4367a6468a7a0938d85c0a1";

    return rsa_from_chars(mod, exp, priv);
}


unsigned char msg_14[43] =
{
    0x10, 0x47, 0x35, 0xd9, 0xad, 0x72, 0x60, 0x46, 0x47, 0x3d, 0xf4, 0xb1, 0x3b, 0x2f, 0x5f, 0xa2,
    0x85, 0xc3, 0xd2, 0x33, 0xec, 0xd4, 0x61, 0x70, 0x58, 0x2d, 0xd2, 0x28, 0xcd, 0xee, 0x46, 0x4d,
    0xa5, 0x09, 0x5e, 0x20, 0x8c, 0xf8, 0xfb, 0xca, 0x05, 0x38, 0x8b
};

unsigned char rnd_14[146] =
{
    0xdc, 0x6a, 0x63, 0x1e, 0x29, 0x75, 0x45, 0xd2, 0xf6, 0xfe, 0x9c, 0x69, 0xa5, 0xd3, 0x06, 0xa1,
    0x09, 0x16, 0xd7, 0xe7, 0xef, 0x0d, 0xc9, 0x53, 0xf2, 0x1b, 0x6a, 0x04, 0x14, 0x31, 0xec, 0x8b,
    0xa5, 0xce, 0x1c, 0x13, 0x87, 0x43, 0xfa, 0xac, 0x54, 0x97, 0xd6, 0x99, 0xf2, 0xff, 0x1d, 0x4a,
    0x44, 0xa3, 0xe0, 0x63, 0x7c, 0xc5, 0xe5, 0xe6, 0x38, 0xcd, 0x73, 0x67, 0x7d, 0x09, 0xaf, 0xee,
    0x3e, 0xc9, 0xfe, 0x80, 0x52, 0x94, 0x7a, 0x73, 0x33, 0x4c, 0x32, 0x70, 0x47, 0x28, 0x56, 0xf3,
    0x07, 0x24, 0x3a, 0xc5, 0x8b, 0xf8, 0x63, 0x80, 0x74, 0x66, 0x7d, 0x7f, 0x7c, 0x18, 0xe3, 0xab,
    0x32, 0x7e, 0xa3, 0xfc, 0x78, 0x91, 0xf1, 0xc5, 0x8a, 0xb4, 0x7e, 0x4f, 0xfa, 0x6e, 0x7d, 0x90,
    0x11, 0xa3, 0x3d, 0x9b, 0x40, 0xa2, 0xd7, 0x89, 0xee, 0x42, 0x21, 0x25, 0x62, 0x30, 0xca, 0x8a,
    0x61, 0x81, 0x1b, 0x09, 0x72, 0xcf, 0xd9, 0x86, 0x01, 0x75, 0x26, 0x18, 0x1d, 0x24, 0xee, 0xbb,
    0x32, 0xcc
};

unsigned char enc_14[192] =
{
    0x92, 0x1d, 0x2b, 0x02, 0x6d, 0x6b, 0x7e, 0x22, 0x20, 0x1d, 0xe7, 0x7f, 0xbf, 0x67, 0x99, 0x90,
    0xf9, 0xaf, 0xf4, 0xea, 0x7f, 0xe7, 0xce, 0x45, 0x02, 0x21, 0x5f, 0x9e, 0x7a, 0xa4, 0x18, 0xb8,
    0x5f, 0x72, 0xea, 0xdb, 0x6b, 0x69, 0x42, 0xbb, 0x08, 0xa0, 0x8b, 0xe7, 0xda, 0x66, 0x19, 0xaa,
    0x5f, 0x1d, 0x2f, 0xf9, 0x61, 0xc9, 0xdc, 0x2c, 0x34, 0x1a, 0xe3, 0x2a, 0x25, 0x4f, 0xde, 0xab,
    0xa2, 0xf6, 0x45, 0x0a, 0xc4, 0x47, 0x4b, 0x62, 0x74, 0xf0, 0xc3, 0x46, 0xf2, 0x6d, 0xa4, 0xed,
    0x55, 0x5a, 0x8c, 0x95, 0x11, 0x89, 0xdc, 0x83, 0x69, 0xf3, 0x4d, 0x76, 0xd8, 0x37, 0xd6, 0xf3,
    0x8a, 0x95, 0x18, 0xa6, 0x27, 0x1c, 0x5b, 0x56, 0x34, 0x62, 0x25, 0xa5, 0xab, 0x8d, 0xa6, 0x03,
    0x2a, 0x59, 0x30, 0xfd, 0x5b, 0x77, 0x72, 0x9d, 0xe6, 0x32, 0xe1, 0x75, 0x2f, 0xc7, 0x2a, 0x0c,
    0x34, 0xae, 0xce, 0x25, 0x65, 0x7b, 0x28, 0x1b, 0xe8, 0x93, 0x2c, 0x56, 0x50, 0xc9, 0x82, 0xfa,
    0x14, 0x5f, 0xde, 0x0b, 0xcd, 0xd4, 0x8a, 0x73, 0xaa, 0x02, 0x88, 0xb4, 0xde, 0x46, 0x11, 0x33,
    0xf2, 0x7d, 0x51, 0xe3, 0x86, 0x01, 0x6a, 0x72, 0x72, 0x6a, 0x9e, 0xde, 0x1d, 0x32, 0xdf, 0xc7,
    0xe6, 0xf9, 0x78, 0x0c, 0x04, 0xeb, 0x70, 0xff, 0xff, 0xc2, 0x68, 0x82, 0x95, 0x66, 0x73, 0x33
};

/* Example 15.1 (2048 bits) */

rsa_t *create_key15_test(void)
{
    char *mod="dcfa10ffa74665aeef870974ea99b2ce54547c67f42aaa6dd01a2ed31fd2c242"
              "af5d960b1f896efba3543d6554b7b12687a5c688568f32e026c532d25993b97a"
              "7c2842ec2b8e1235eee2414d25806c6fbae438954eba9d2755dffeeb1b477009"
              "57815a8a233f97b1a2c714b3e2be2e42d8be30b1961582ea9948910e0c797c50"
              "fc4bb455f0fc45e5e34e6396ac5b2d46239365c7f3daaf0909400d61cf9e0ca8"
              "083eaf335a6fceb6863c1cc0cf5a171aff35d97ecb60ef251c7ec2c8a588361d"
              "c41266a4b7ed38b026ce0d53786449dbb11a06ea33ccf1eca575201ed1aa473e"
              "d1187ec1d8a744ea345bed7ea00ee4e81bba4648601dd537dc91015d31f0c2c1";

    char *exp="010001";

    char *priv="21950851cdf25320318b305afa0f371f07ae5a44b314ebd729f5dcb15da7fa39"
               "47acdd915daed574bd16df88bf85f61060b387172fae6e01262b3864c2d3c22f"
               "94e04a8159422b4ed279c48a4c9d767d4966071a5bbf5d043e16ff46ec1ba071"
               "6f00bbc97bff5d5693e214e99c9721f12b3ec6282ae2a485721b96ddcf7403fa"
               "037d0c57ab463c448de5cc12265add886d311ea8d8a5903fa56c5f1c9cf2eb11"
               "cb657a1a7d3e41352dc3e686898c4ce4305e8b638e1b08a2a86cc9eb9866f349"
               "9ac77b6136b81cb276d614cfeb7b6ed3f3bc775e46c00066ebeee2cff7166b57"
               "520598947ff6210320b288fb4f2c3f8fe97b279414ebf7203000a19fc0424875";

    return rsa_from_chars(mod, exp, priv);
}

unsigned char msg_15[19] = 
{
    0x2a, 0xac, 0xec, 0x86, 0xf4, 0x23, 0xdd, 0x92, 0x5e, 0xc1, 0x58, 0x82, 0x2a, 0x74, 0x8c, 0xbe, 0x6c, 0x31, 0xa0
};

unsigned char rnd_15[250] =
{
    0xcc, 0x4b, 0x87, 0xf6, 0x74, 0x49, 0x7b, 0xb0, 0xe3, 0x3d, 0x9e, 0x2a, 0x4a, 0x80, 0x70, 0xb7,
    0xd7, 0x8b, 0x5f, 0xd2, 0xc4, 0xb4, 0xf6, 0xeb, 0xac, 0xcd, 0x4e, 0xe5, 0x05, 0xb7, 0x1f, 0xca,
    0xfe, 0x21, 0x56, 0x33, 0x7d, 0xdf, 0x27, 0xb4, 0x75, 0xaf, 0x33, 0xf6, 0xc3, 0x40, 0x5b, 0x8e,
    0x3c, 0x0c, 0x20, 0x6e, 0xc2, 0x81, 0x29, 0x22, 0xfc, 0xd8, 0xa3, 0x66, 0x1b, 0x86, 0x19, 0xbb,
    0xc1, 0x82, 0xf8, 0x07, 0xf3, 0xa1, 0x07, 0x2e, 0x62, 0xca, 0x2b, 0xf1, 0xfa, 0x8b, 0x94, 0x4e,
    0x58, 0xa0, 0xe2, 0x03, 0xdb, 0xb7, 0x53, 0xf9, 0xf1, 0xb6, 0xef, 0x62, 0x7e, 0xbe, 0xe5, 0x98,
    0x96, 0x7b, 0x38, 0x7a, 0x5f, 0x96, 0x36, 0xd8, 0xb6, 0x41, 0xb3, 0x89, 0x84, 0xb1, 0xca, 0x03,
    0x7e, 0x3a, 0xae, 0xaa, 0x17, 0x10, 0xf5, 0x16, 0x25, 0xea, 0x85, 0xf8, 0xfb, 0x9a, 0x6e, 0x02,
    0x9e, 0x64, 0x57, 0x58, 0x14, 0xd5, 0x30, 0xfc, 0x14, 0x6b, 0x34, 0x45, 0xac, 0x42, 0x01, 0xb4,
    0xe4, 0x08, 0xad, 0xf6, 0x55, 0xf6, 0x78, 0x43, 0xd8, 0x87, 0x1c, 0xac, 0xe5, 0xd9, 0x06, 0xd7,
    0xfc, 0x03, 0x8f, 0xea, 0x88, 0x5b, 0x96, 0xfb, 0x8e, 0xb1, 0xa7, 0x21, 0xc6, 0xc1, 0x4a, 0xbb,
    0xeb, 0x78, 0xfb, 0x4c, 0x79, 0x8a, 0x19, 0x58, 0x99, 0x59, 0x89, 0x84, 0x55, 0xa3, 0x16, 0x84,
    0x3c, 0x6c, 0xd9, 0x9e, 0xf5, 0x8c, 0x2b, 0x0b, 0x49, 0xb8, 0xab, 0x41, 0x91, 0xb4, 0x02, 0xa5,
    0x4c, 0x92, 0x97, 0x31, 0x0c, 0xd2, 0x24, 0xb1, 0x7f, 0x21, 0x41, 0x67, 0x72, 0x5c, 0x48, 0xfc,
    0xc6, 0x1b, 0xc4, 0x7c, 0xfa, 0xcc, 0xf1, 0x5e, 0xb3, 0xb0
};

unsigned char enc_15[256] =
{
    0x60, 0x42, 0xe7, 0x45, 0x58, 0x9a, 0xf0, 0x3a, 0xf8, 0x75, 0x20, 0xf9, 0x3c, 0x45, 0xd8, 0xc3,
    0x59, 0x85, 0xad, 0xa1, 0x16, 0x1a, 0x37, 0xd8, 0x22, 0xe9, 0xf9, 0x46, 0x0f, 0xc7, 0x5f, 0xcf,
    0x01, 0x79, 0xd8, 0x49, 0x1b, 0x8f, 0x5d, 0x1e, 0x4d, 0xe8, 0xce, 0xb3, 0x1e, 0x07, 0xc4, 0x86,
    0x5c, 0x5a, 0x3e, 0xfd, 0xbb, 0xb6, 0x9a, 0x88, 0x03, 0xb8, 0x9e, 0xe6, 0x5a, 0x43, 0x0a, 0x58,
    0x09, 0xc7, 0x07, 0x56, 0x91, 0x50, 0xb5, 0x80, 0xbb, 0x68, 0x6a, 0x94, 0xc5, 0x54, 0x1c, 0x46,
    0xad, 0xcd, 0x82, 0x79, 0x60, 0xce, 0x24, 0x4f, 0xf6, 0x88, 0x38, 0x7d, 0x16, 0x16, 0xe8, 0x5b,
    0x4d, 0x17, 0x80, 0xc6, 0x48, 0x36, 0x06, 0xcf, 0x92, 0x4b, 0x54, 0xf0, 0x80, 0xcf, 0x41, 0x54,
    0xe6, 0x68, 0x29, 0xbf, 0x6e, 0x53, 0x24, 0x81, 0x04, 0x8e, 0xc4, 0x1f, 0xad, 0xc0, 0x7d, 0x75,
    0x5b, 0xb3, 0x4b, 0xb2, 0x81, 0x45, 0x21, 0x9c, 0xb3, 0x0d, 0x47, 0xd0, 0xd6, 0x18, 0x70, 0x91,
    0x80, 0xe9, 0x03, 0x03, 0xff, 0x9e, 0xf0, 0x90, 0x18, 0xbe, 0xd3, 0xda, 0x75, 0x76, 0x1d, 0xa7,
    0x94, 0x81, 0x1f, 0x96, 0xbc, 0x9e, 0x8d, 0x7c, 0x4b, 0xa1, 0xb5, 0x94, 0x6b, 0xda, 0x0b, 0xd3,
    0x13, 0xfa, 0xec, 0x4c, 0x99, 0x3e, 0xd2, 0x74, 0x8e, 0xed, 0x8c, 0xce, 0x4b, 0xdb, 0x52, 0x0b,
    0xa7, 0xdb, 0x16, 0x5f, 0x9f, 0xe5, 0x6a, 0xa8, 0x45, 0x4d, 0x6f, 0xf3, 0x38, 0x74, 0xfe, 0xee,
    0xbf, 0x29, 0xde, 0x2d, 0xf5, 0xb7, 0xf0, 0x0a, 0xa1, 0xd9, 0xfb, 0x07, 0x3f, 0xc4, 0x06, 0x7b,
    0x58, 0xdc, 0x50, 0x62, 0x4e, 0x12, 0x7f, 0x71, 0x1d, 0xde, 0x2c, 0xc2, 0xcf, 0xda, 0xb4, 0x91,
    0x9c, 0xcf, 0x28, 0xc8, 0x36, 0x60, 0xdf, 0xc2, 0x27, 0xb0, 0xf5, 0x00, 0xec, 0x1f, 0x90, 0x4f
};

/* ------------------------------------------------ *
   This 'random' context provides the exact random
   bytes neded by rsa_encode() to generate the 
   correct padding bytes for the text vectors, 
   which is 'rdat' parameter for test_rsa_key()
 * ------------------------------------------------ */

typedef struct
{
    unsigned char *buf;
    size_t pos, tam;
} rnd_rsa_t;

void rnd_bytes(rnd_rsa_t *rc, void *datos, size_t tam)
{

    size_t t;
    unsigned char *ptr = (unsigned char *)datos;

    for (t = 0; t < tam; t++)
    {
        ptr[t] = rc->buf[rc->pos++];
        if (rc->pos == rc->tam)
            rc->pos = 0;
    }
}

unsigned int rnd_uints(rnd_rsa_t *rc)
{
    unsigned int ret = 0, t;

    for (t = 0; t < sizeof(int); t++)
    {
        ret <<= 4;
        ret |= rc->buf[rc->pos++];
        if (rc->pos == rc->tam)
            rc->pos = 0;
    }
    return ret;
}

/* --------------- */

void test_rsa_key(rsa_t *key, unsigned char *msg, int mlen, unsigned char *rdat, int rlen, unsigned char *enc, int tam)
{
    unsigned char txt[RSA_MAX_BYTES];
    int len;
    rnd_rsa_t *rnd;
    rand_t *rc;

    rc = rand_create(sizeof(rnd_rsa_t), (rand32_func_t)rnd_uints, (rand8_func_t)rnd_bytes, NULL, NULL);
    if (rc == NULL)
    {
        printf("Memory ERROR\n");
        return;
    }

    print_rsa_key(key);

    rnd = (rnd_rsa_t *)rc->ctx;

    rnd->buf = rdat;
    rnd->pos = 0;
    rnd->tam = rlen;

    memcpy(txt, msg, mlen);
    print_bytes("TXT ", msg, mlen);

    printf("Encoding with Public Key...\n");

    len = rsa_encode(key, txt, mlen, TRUE, RSA_PAD_RANDOM, rc);

    rand_end(rc);

    print_bytes("RSA ", txt, len);
    print_bytes("ENC ", enc, tam);

    printf("memcmp(%d,%d) = %s\n", len, tam, memcmp(enc, txt, len) ? "FAILED" : "CORRECT");

    printf("Decoding with Private Key...\n");

    len = rsa_decode(key, txt, len, FALSE, RSA_PAD_RANDOM);
    if (len < mlen)
    {
        printf("ERROR %d!!!", len);
    }
    else
    {
        print_bytes("STR ", txt, len);
        print_bytes("TXT ", msg, len);
    }

    rsa_destroy(key);
    
}

/* --------------- */

static void test_rsa_rnd(int cual,int seed)
{
    rsa_t *rsa = NULL;
    rand_t *rng;    

    printf("\n===== Test RSA Key =====\n");

    rng = rand_start(cual, seed);
    if (rng)
        printf("Generate key using generator '%s' and seed %d...\n",rand_name(rng),seed);
    else
        printf("NULL rng\n");

    rsa = rsa_generate_keys(1024, 0, rng);
    if (rsa)
    {
        int verifica;

        print_rsa_key(rsa);

        printf("Verifiying key...");
        fflush(stdout);

        verifica = rsa_verify_keys(rsa);

        printf("%s\n", (verifica) ? "VERIFIED" : "FAILED");
    }
    
    printf("\nTest PKCS#1 v1.5 - Example 1\n");
    test_rsa_key(create_key1_test(), msg_1, 26, rnd_1, 99, enc_1, 128);
    printf("\nTest PKCS#1 v1.5 - Example 14.2\n");
    test_rsa_key(create_key14_test(), msg_14, 43, rnd_14, 146, enc_14, 192);
    printf("\nTest PKCS#1 v1.5 - Example 15.1\n");
    test_rsa_key(create_key15_test(), msg_15, 19, rnd_15, 250, enc_15, 256);

    printf("\n");

    rand_end(rng);
}

/* ------------------------------------------------------------------------------- *

   RSA Signature Test from Wei Day test vectors of PKCS-1 v1.5 

   https://github.com/weidai11/cryptopp/blob/master/TestVectors/rsa_pkcs1_1_5.txt 

 * ------------------------------------------------------------------------------- */

/* Example 1.4 (1024 bits) */

rsa_t *create_key_sign_test1(void)
{
    char *mod="0a66791dc6988168de7ab77419bb7fb0c001c62710270075142942e19a8d8c51"
                    "d053b3e3782a1de5dc5af4ebe99468170114a1dfe67cdc9a9af55d655620bbab";

    char *exp="010001";

    char *pri="0123c5b61ba36edb1d3679904199a89ea80c09b9122e1400c09adcf7784676d0"
                    "1d23356a7d44d6bd8bd50e94bfc723fa87d8862b75177691c11d757692df8881";

    return rsa_from_chars(mod, exp, pri);
}

/*  */

rsa_t *create_key_sign_test2(void)
{
    char *mod="a885b6f851a8079ab8a281db0297148511ee0d8c07c0d4ae6d6fed461488e0d4"
                    "1e3ff8f281b06a3240b5007a5c2ab4fb6be8af88f119db998368dddc9710abed";

    char *exp="010001";

    char *pri="2b259d2ca3df851ee891f6f4678bddfd9a131c95d3305c63d2723b4a5b9c960f"
                    "5ec8bb7dcddbebd8b6a38767d64ad451e9383e0891e4ee7506100481f2b49323";

    return rsa_from_chars(mod, exp, pri);
}

unsigned char sign_msg1[25] = /* Message:  "Everyone gets Friday off." */
{
    0x45, 0x76, 0x65, 0x72, 0x79, 0x6f, 0x6e, 0x65, 0x20, 0x67, 
    0x65, 0x74, 0x73, 0x20, 0x46, 0x72, 0x69, 0x64, 0x61, 0x79, 
    0x20, 0x6f, 0x66, 0x66, 0x2e
};

unsigned char sign_val1[64] =    /* Signature */
{
	0x05, 0xfa, 0x6a, 0x81, 0x2f, 0xc7, 0xdf, 0x8b, 0xf4, 0xf2, 0x54, 0x25, 0x09, 0xe0, 0x3e, 0x84,
	0x6e, 0x11, 0xb9, 0xc6, 0x20, 0xbe, 0x20, 0x09, 0xef, 0xb4, 0x40, 0xef, 0xbc, 0xc6, 0x69, 0x21, 
    0x69, 0x94, 0xac, 0x04, 0xf3, 0x41, 0xb5, 0x7d, 0x05, 0x20, 0x2d, 0x42, 0x8f, 0xb2, 0xa2, 0x7b, 
    0x5c, 0x77, 0xdf, 0xd9, 0xb1, 0x5b, 0xfc, 0x3d, 0x55, 0x93, 0x53, 0x50, 0x34, 0x10, 0xc1, 0xe1
};

unsigned char sign_msg2[4] = /* Message:  "test" */
{
    0x74, 0x65, 0x73, 0x74 
};

unsigned char sign_val2[64] = /* Signature */
{
    0xa7, 0xe0, 0x0c, 0xe4, 0x39, 0x1f, 0x91, 0x4d, 0x82, 0x15, 0x8d, 0x9b, 0x73, 0x27, 0x59, 0x80, 
    0x8e, 0x25, 0xa1, 0xc6, 0x38, 0x3f, 0xe8, 0x7a, 0x51, 0x99, 0x15, 0x76, 0x50, 0xd4, 0x29, 0x6c, 
    0xf6, 0x12, 0xe9, 0xff, 0x80, 0x9e, 0x68, 0x6a, 0x0a, 0xf3, 0x28, 0x23, 0x83, 0x06, 0xe7, 0x99, 
    0x65, 0xf6, 0xd0, 0x13, 0x81, 0x38, 0x82, 0x9d, 0x9a, 0x1a, 0x22, 0x76, 0x43, 0x06, 0xf6, 0xce
};

void rsa_test_signature(void)
{
    unsigned char tmp[128];
    int ret;
    rsa_t *k1,*k2;

    printf("\n===== Test RSA signature =====\n");

    k1 = create_key_sign_test1();
    if(k1)
    {

        printf("Test with Key 1\n");
        print_bytes("TXT ", sign_msg1, 25);
        print_bytes("SIGN", sign_val1, 64);
        ret = rsa_sign(k1,tmp,128,HASH_MD2,sign_msg1,25,RSA_PAD_ONES);
        if(ret < 1)
            printf("ERROR %d signing with MD2\n",ret);
        else    
            print_bytes("RES ", tmp, ret);
        printf("Result is %sorrect\n\n",memcmp(tmp,sign_val1,ret) ? "in" : "c");
        rsa_destroy(k1);
    }
    else
    {
        printf("Key 1 could not be created\n");
    }

    k2 = create_key_sign_test2();
    if(k2)
    {
        printf("Test with Key 2\n");
        print_bytes("TXT ", sign_msg2, 4);
        print_bytes("SIGN", sign_val2, 64);
        ret = rsa_sign(k2,tmp,128,HASH_SHA1,sign_msg2,4,RSA_PAD_ONES);
        if(ret < 1)
            printf("ERROR %d signing with MD2\n",ret);
        else    
            print_bytes("RES ", tmp, ret);
        printf("Result is %sorrect\n\n",memcmp(tmp,sign_val2,ret) ? "inc" : "c");
        rsa_destroy(k2);
    }
    else
    {
        printf("Key 2 could not be created\n");
    }

}


/* -------------------------------------- */

void usage(void)
{
    printf("\nTEST RSA\n\nuse:\ttest_rsa alg [seed] [bits]\n\n"
           "Test different RSA things using 'alg' algorithm.\n"
           "'seed' is a number used to seed the algorithm. Unless is 0, which\n"
           "makes the algorithm to be seeded with an umpredictable number.\n"
           "'bits' is the number of bits of the primes (default 768)\n\n"
           "Algorithms:\n\n\t1 = Mother of George Marsaglia (RAND_GM)\n"
           "\t2 = Mersenne Twister of Matsumoto & Nishimura (RAND_MT)\n"
           "\t3 = Xorshift of George Marsaglia (RAND_GX)\n"
           "\t4 = TLS-PRF-MD5_SHA1 (RAND_TLS_MD5_SHA1)\n"
           "\t5 = TLS-PRF-SHA256 (RAND_TLS_SHA256)\n"
           "\t6 = TLS-PRF-SHA384 (RAND_TLS_SHA384)\n"
           "\t7 = OSSYS of Kenneth MacKay (RAND_OS)\n"
           "\n"
        );

}


/* -------------------------------------- */

int main(int argc,char **argv)
{
    int arg = 1,alg = 0, seed = 0,bits = 768;    

    if(arg < argc)
    {
        alg = atoi(argv[arg++]);
        if(arg < argc)
        {
            seed = atoi(argv[arg++]);        
            if(arg < argc)
                bits = atoi(argv[arg++]);        
        }
    }

    if(alg < RAND_NONE + 1 || alg > RAND_NUM - 1)
    {
        usage();
    }
    else
    {
        test_rsa_rnd(alg,seed);      
        rsa_test_signature();  
        //test_rsa(alg,seed,bits);
    }        
    return 0;
}
